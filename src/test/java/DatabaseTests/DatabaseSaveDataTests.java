package DatabaseTests;

import database.Database;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.mockito.Mockito.*;

public class DatabaseSaveDataTests {

    Database database;
    Connection mockConnection;
    PreparedStatement mockPreparedStatement;

    @BeforeEach
    public void setUp() throws SQLException {

        database = spy(new Database("test.db")); // create a spy

        // Mock connection and prepared statementss
        mockConnection = mock(Connection.class);
        mockPreparedStatement = mock(PreparedStatement.class);

        // Set up the mock to return mockStatement when any SQL string and any integer  (which is normally used for specifying keys that are autogenerated)
        // are passed to further to prepareStatement.
        // This basically allows us to simulate preparing a SQL insert query and returning a mock PreparedStatement
        // which then allows us to verify if the correct SQL command is executed and with the right params
        when(mockConnection.prepareStatement(anyString(), anyInt())).thenReturn(mockPreparedStatement);

        // Override connect method in database
        // prevent the actual db from opening -> instead use mock connection
        // that allows ut o test logic and stuff without affecting real db
        doReturn(mockConnection).when(database).connect();
    }

    @Test
    @DisplayName("Save an user -> Insert a new row into User table")
    public void testSaveUserIntoDatabase() throws SQLException {
        // act
        database.saveUser("Blazej");

        //assert
        verify(mockConnection).prepareStatement(
                "INSERT INTO Users (name) VALUES (?)", PreparedStatement.RETURN_GENERATED_KEYS
        );
        verify(mockPreparedStatement).setString(1, "Blazej");
        verify(mockPreparedStatement).executeUpdate();
    }

    @Test
    @DisplayName("Saved user returns newly generated ID")
    public void testSaveUserReturnsNewlyGeneratedId() throws SQLException {
        // arrange -> set up mock to return genereted ID
        ResultSet mockResultSet1 = mock(ResultSet.class);
        when(mockPreparedStatement.getGeneratedKeys()).thenReturn(mockResultSet1);
        when(mockResultSet1.next()).thenReturn(true); // for time being simulate that there is indeed a result
        when(mockResultSet1.getInt(1)).thenReturn(1); // then mock returns 1 as the generated ID

        // act -> call saveUser and get the id
        int userID = database.saveUser("Blazej");

        // arrange again
        ResultSet mockResultSet2 = mock(ResultSet.class);
        when(mockPreparedStatement.getGeneratedKeys()).thenReturn(mockResultSet2);
        when(mockResultSet2.next()).thenReturn(true); // Simulate that there's a generated key
        when(mockResultSet2.getInt(1)).thenReturn(2); // Second user has ID 2

        // act 2
        int userID2 = database.saveUser("Kamilla");

        // assert -> Veerify the ids are indeed inque -> not equals
        assertNotEquals(userID, userID2);
    }
}
